컴퓨터 그래픽스 0628

용어정리
사전적 정의를 하기보다는 본인이해본 경험을 바탕으로 해당 단어를 설명하기 위해 노력할 것
위 설명이 어려운 경우 사전적 정의라도 이야기 할 수 있어야함

WinAPI 함수로 구성
MFC

동적바인딩: 프로그램 실행 도중에 함수의 기능이 결정되는 것(동적할당된 메모리에 따라 다름)
정적바인딩 프로그램 실행(컴파일) 이전 함수의 기능이 결정되는 것

플랫폼: 서비스를 제공하는 주체 (예: 카카오 네이버 등)
>> 소프트웨어: 운영체제, SDK (예: 윈도우 안드로이드 유니티 아마존클라우드 asure)
콜백: 알 수 없는 곳에서 호출되고 있는 것, 함수에 주소값을 넘기면 필요할 떄 플랫폼(OS)에서 처리함
콜백함수:
메세지: 운영체제가 어떤 상황이 되었을 때 보내는 것.
핸들러:이벤트의 발생 조건을 지정하는 것.
이벤트: (핸들러를 통해?) 이전 상태와 달라지는 것.


콘솔:
크로스플랫폼:
빌드: 실행하려는 기기에 맞게 파일을 수정하는 것
SDK: 소프트웨어 개발 도구 (software develope kit)
클라우드: 어떤 서비스를 제공하는 것
클라우드 게임 서비스: 클라우드 서비스 내에서 게임이 실행됨
백도어: 정상적인 루트가 아닌 우회하는 루트
함수 포인터: 함수의 주소값을 저장한다.
운영체제: 기기와 상관없이 설치만 되면 소프트웨어 사용가능
드라이버: 운영체제에 맞게 하드웨어를 사용할 수 있도록 도와주는 프로그램
D3D: 풀스크린 모드를 지원하여 모든 하드웨어 기기에서 온전하게 실행 될 수 있도록 만듦

WM_CREATE 실행될 때
WM_COMMAND 
WM_PAINT 그려질 때
WM_DESTROY 종료될 때

집에 가서 할일
MFC 뜯어보기
콜백, 함수 포인터

0701

정적 라이브러리
동적 라이브러리
DLL

데이터 : 버튼
-> 변수
알고리즘 : 버튼 누를 시 버튼 안에 있는 텍스트를 변경
-> 이벤트, 함수

핸들러 동작 => 이벤트 발생
키보드 방향키 입력 => 캐릭터 이동

MFC 학습중 >> 디버깅으로 실행 과정을 시각적으로 알기 어려운 경우 콘솔로 띄워주는 라이브러리, 함수 활용
_cPrint(), AllocConsole()

쓰레드:

설계가 중요한가 >> 무경험자, 신입 경력에게는 중요하지 않은 분야임, 알고 있으면 좋겠으나 확실하게 알아야 좋은 것
설계에 대해 애매한 지식으로 진행하면 문제가 크게 발생
확실하지 않으면 시도안하는 게 좋음

온라인게임 -> 기존 프로그램 코드를 유지보수 한는 방향 -> 발전X
싱글게임 -> 기존의 코드를 개선시키는 방향 -> 발전O
헝가리안식 표기: 콘솔을 활용한 이벤트 발생 경위추적

0702
프로세스: 
쓰레드: 
멀티 쓰레드: 
void 포인터: 타입이 없는 포인터 
포인터: 
동적 할당: 
malloc: 
변수에 타입이 필요한 이유: 크기가 필요한 이유 
변수에 표현범위가 있는 이유: 2진수의 범위에 맞춰서 데이터를 맵핑되어있음.
오버플로우: 
언더플로우: 
STL: 
32bit 운영체제 -> 4기가(2^32)까지 수용 -> 포인터는 4기가 이상 수용할 수 없음
64bit 운영체제로 발전
long Pointer: 2^32 타입의 포인터



printf할 때 표현방법을 정해줘야 하는이유
>> 예) %d, %s, %f, %c, ....등?
메모리는 데이터 덩어리일 뿐, 디코딩 단계에서 어떻게 해석하느냐에 따라 달라짐.
치트엔진: 메모리는 읽어서 값을 덮어씌움
메모리 난독화:
serialize: 

동적할당: 
정적할당: 
메모리누수: 동적할당된 메모리를 해제하지 않으면, 메모리 누수가 발생하여 할당할 수 없는 상태가 됨
메모리 페이징: 가용메모리는 있으나, 빈공간이 발생하여 더이상 메모리를 할당할 수 없는 상태

프로세스: 
Task: 
Thread: 
Async: 
Job Scheduler: 
CPU에서 스레드 처리방식: 
듀얼 코어에서 게임 처리방식: 
멀티 코어에서 게임 처리방식: 
오버헤드: 가장 효율적인 처리시간에 비교해서 처리가 효율적이지 못해 생기는 문제
컨텍스트 스위칭: 작업을 변경하기 위해서 준비하는 단계


0703(수)

멀티바이트: 
유니코드: 
캐싱: 
버퍼링: 
컴파일:  
링킹: 
로딩: 
프로세스 생명주기: 
교착상태: 
스케줄링:
>> 선점:
>> 비선점: 

static멤버: 객체 없이도 함수 혹은 변수에 접근할 수 있음

코루틴과 비슷한 함수가 기억이 안나네

0704(목)
디자인 패턴을 어설프게 사용할 바에 안쓰는 게 나음
책 추천 >> GoF의 디자인패턴

디자인 패턴:

일반화: 상속
실체화: 가상클래스를 상속받아 자식클래스로 구현하는 것
의존(사용): has a 아님, 객체의 참조를 유지하지 않고 사용하는 것
>> 객체 내부에 저장하지 않고 사용
연관 (has a): 객체내부에 참조를 저장함

정적멤버변수: 

객체: 
C++
>> 객체(=인스턴스) -> 메모리가 할당된 클래스의 변수
SingleObject objSingle; //정적할당된 객체(인스턴스) >> 변수 타입에 따라 삭제되는 시기가 결정
SingleObject pObjSingle = new SingleObject();// 동적할당된 객체 >> 동적할당해제
C#
>> 인스턴스의 참조값을 저장하는 변수
인스턴스:
C++
>> 인스턴스(=객체)
C#
>> 클래스를 동적할당하여 만들어진 참조된 대상

클래스: 객체는 참조자, 객체를 사용하려면 객체를 할당하거나 참조해야한다.
class SingleObject;
SingleObject objSingle = new SingleObject()
				객체(참조자)		인스턴스

구조체: 객체가 정적할당된다.
>> 스탯: 값을 복사해서 가져가므로 공유되는 문제가 발생하지않음
struct SingleObject;
SingleObject objSingle = new SingleObject()
				객체(정적할당)		생성자의 호출(객체에 값을 할당)

참조: 

0705(금)

디자인 패턴
데코레이트: 
옵저버: 

상속할 때 부모의 

오버로딩: 같은 메서드를 여러 개 만드는 것 >> 메서드의 매개변수가 다름
오버라이딩: 상속받은 함수를 자식클래스에서 재정의하는 것

정적할당된 메모리는 스택에 할당된다.
동적할당된 메모리는 힙에 할당된다.
스택 오버플로우: (정적할당된) 메모리가 너무 많아져 스택의 크기보다 많이 할당함.
공부하면 좋을 것 >> 메모리 구조

무한 재귀에 스택오버 플로우가 발생한다
>> 단순 반복이 많은 횟수가 반복될 때에는 재귀를 사용해서는 안된다.

재귀를 써야하는 이유
>> 트리를 직접 만들어보면 알게됨
트리 -> 탐색 >> 스택을 사용하지않게 하기위해 >> 함수가 호출될 때마다 지역변수가 스택에 할당되어 이전의 데이터에 접근할 수 있어서

가상함수: 
가상함수테이블: 
추상화: 
실체화: 
동적바인딩: 함수의 기능이 런타임 때 결정
>>함수포인터에 할당된 참조하는 함수의 주소값이 바뀐다
>>부모객체에 자식객체를 할당하면 가상함수가 자식의 기능으로 작동한다
>>콜백함수를 등록한다
여기서 연계해도 괜찮은 것
>> 델리게이트(C#): 