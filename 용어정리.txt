컴퓨터 그래픽스 0628

용어정리
사전적 정의를 하기보다는 본인이해본 경험을 바탕으로 해당 단어를 설명하기 위해 노력할 것
위 설명이 어려운 경우 사전적 정의라도 이야기 할 수 있어야함

WinAPI 함수로 구성
MFC

동적바인딩: 프로그램 실행 도중에 함수의 기능이 결정되는 것(동적할당된 메모리에 따라 다름)
정적바인딩: 프로그램 실행(컴파일) 이전 함수의 기능이 결정되는 것

플랫폼: 서비스를 제공하는 주체 (예: 카카오 네이버 등)
>> 소프트웨어: 운영체제, SDK (예: 윈도우 안드로이드 유니티 아마존클라우드 asure)
콜백: 알 수 없는 곳에서 호출되고 있는 것, 함수에 주소값을 넘기면 필요할 떄 플랫폼(OS)에서 처리함
콜백함수:
메세지: 운영체제가 어떤 상황이 되었을 때 보내는 것.
핸들러:이벤트의 발생 조건을 지정하는 것.
이벤트: (핸들러를 통해?) 이전 상태와 달라지는 것.


콘솔:
크로스플랫폼:
빌드: 실행하려는 기기에 맞게 파일을 수정하는 것
SDK: 소프트웨어 개발 도구 (software develope kit)
클라우드: 어떤 서비스를 제공하는 것
클라우드 게임 서비스: 클라우드 서비스 내에서 게임이 실행됨
백도어: 정상적인 루트가 아닌 우회하는 루트
함수 포인터: 함수의 주소값을 저장한다.
운영체제: 기기와 상관없이 설치만 되면 소프트웨어 사용가능
드라이버: 운영체제에 맞게 하드웨어를 사용할 수 있도록 도와주는 프로그램
D3D: 풀스크린 모드를 지원하여 모든 하드웨어 기기에서 온전하게 실행 될 수 있도록 만듦

WM_CREATE 실행될 때
WM_COMMAND 
WM_PAINT 그려질 때
WM_DESTROY 종료될 때

집에 가서 할일
MFC 뜯어보기
콜백, 함수 포인터

0701

정적 라이브러리: 
동적 라이브러리: 
DLL: 

데이터 : 버튼
-> 변수
알고리즘 : 버튼 누를 시 버튼 안에 있는 텍스트를 변경
-> 이벤트, 함수

핸들러 동작 => 이벤트 발생
키보드 방향키 입력 => 캐릭터 이동

MFC 학습중 >> 디버깅으로 실행 과정을 시각적으로 알기 어려운 경우 콘솔로 띄워주는 라이브러리, 함수 활용
_cPrint(), AllocConsole()

쓰레드:

설계가 중요한가 >> 무경험자, 신입 경력에게는 중요하지 않은 분야임, 알고 있으면 좋겠으나 확실하게 알아야 좋은 것
설계에 대해 애매한 지식으로 진행하면 문제가 크게 발생
확실하지 않으면 시도안하는 게 좋음

온라인게임 -> 기존 프로그램 코드를 유지보수 한는 방향 -> 발전X
싱글게임 -> 기존의 코드를 개선시키는 방향 -> 발전O
헝가리안식 표기: 콘솔을 활용한 이벤트 발생 경위추적

윈도우는 초기에 모든 권한을 계정에 주고, 폴더접근을 제한하지않았기 때문에
파일을 변조할 수 있음.

0702
프로세스: 
쓰레드: 
멀티 쓰레드: 
void 포인터: 타입이 없는 포인터 
포인터: 
동적 할당: 
malloc: 
변수에 타입이 필요한 이유: 크기가 필요한 이유 
변수에 표현범위가 있는 이유: 2진수의 범위에 맞춰서 데이터를 맵핑되어있음.
오버플로우: 
언더플로우: 
STL: 
32bit 운영체제 -> 4기가(2^32)까지 수용 -> 포인터는 4기가 이상 수용할 수 없음
64bit 운영체제로 발전
long Pointer: 2^32 타입의 포인터



printf할 때 표현방법을 정해줘야 하는이유
>> 예) %d, %s, %f, %c, ....등?
메모리는 데이터 덩어리일 뿐, 디코딩 단계에서 어떻게 해석하느냐에 따라 달라짐.
치트엔진: 메모리는 읽어서 값을 덮어씌움
메모리 난독화:
serialize: 

동적할당: 
정적할당: 
메모리누수: 동적할당된 메모리를 해제하지 않으면, 메모리 누수가 발생하여 할당할 수 없는 상태가 됨
메모리 페이징: 가용메모리는 있으나, 빈공간이 발생하여 더이상 메모리를 할당할 수 없는 상태

프로세스: 
Task: 
Thread: 
Async: 
Job Scheduler: 
CPU에서 스레드 처리방식: 
듀얼 코어에서 게임 처리방식: 
멀티 코어에서 게임 처리방식: 
오버헤드: 가장 효율적인 처리시간에 비교해서 처리가 효율적이지 못해 생기는 문제
컨텍스트 스위칭: 작업을 변경하기 위해서 준비하는 단계


0703(수)

멀티바이트: 
유니코드: 
캐싱: 
버퍼:
버퍼링: 
컴파일:  
링킹: 
로딩: 
프로세스 생명주기: 
교착상태: 
스케줄링:
>> 선점:
>> 비선점: 

static멤버: 객체 없이도 함수 혹은 변수에 접근할 수 있음

코루틴과 비슷한 함수가 기억이 안나네

0704(목)
디자인 패턴을 어설프게 사용할 바에 안쓰는 게 나음
책 추천 >> GoF의 디자인패턴

디자인 패턴:

일반화: 상속
실체화: 가상클래스를 상속받아 자식클래스로 구현하는 것
의존(사용): has a 아님, 객체의 참조를 유지하지 않고 사용하는 것
>> 객체 내부에 저장하지 않고 사용
연관 (has a): 객체내부에 참조를 저장함

정적멤버변수: 

객체
C++
>> 객체(=인스턴스) -> 메모리가 할당된 클래스의 변수
SingleObject objSingle; //정적할당된 객체(인스턴스) >> 변수 타입에 따라 삭제되는 시기가 결정
SingleObject pObjSingle = new SingleObject();// 동적할당된 객체 >> 동적할당해제
C#
>> 인스턴스의 참조값을 저장하는 변수

인스턴스
C++
>> 인스턴스(=객체)
C#
>> 클래스를 동적할당하여 만들어진 참조된 대상

클래스: 객체는 참조자, 객체를 사용하려면 객체를 할당하거나 참조해야한다.
class SingleObject;
SingleObject objSingle = new SingleObject()
				객체(참조자)		인스턴스

구조체: 객체가 정적할당된다.
>> 스탯: 값을 복사해서 가져가므로 공유되는 문제가 발생하지않음
struct SingleObject;
SingleObject objSingle = new SingleObject()
				객체(정적할당)		생성자의 호출(객체에 값을 할당)

참조: 

0705(금)

디자인 패턴
데코레이트: 
옵저버: 

상속할 때 부모의 

오버로딩: 같은 메서드를 여러 개 만드는 것 >> 메서드의 매개변수가 다름
오버라이딩: 상속받은 함수를 자식클래스에서 재정의하는 것

정적할당된 메모리는 스택에 할당된다.
동적할당된 메모리는 힙에 할당된다.
스택 오버플로우: (정적할당된) 메모리가 너무 많아져 스택의 크기보다 많이 할당함.
공부하면 좋을 것 >> 메모리 구조

무한 재귀에 스택오버 플로우가 발생한다
>> 단순 반복이 많은 횟수가 반복될 때에는 재귀를 사용해서는 안된다.

재귀를 써야하는 이유
>> 트리를 직접 만들어보면 알게됨
트리 -> 탐색 >> 스택을 사용하지않게 하기위해 >> 함수가 호출될 때마다 지역변수가 스택에 할당되어 이전의 데이터에 접근할 수 있어서

가상함수: 
가상함수테이블: 
추상화: 
실체화: 
동적바인딩: 함수의 기능이 런타임 때 결정
>>함수포인터에 할당된 참조하는 함수의 주소값이 바뀐다
>>부모객체에 자식객체를 할당하면 가상함수가 자식의 기능으로 작동한다
>>콜백함수를 등록한다
여기서 연계해도 괜찮은 것
>> 델리게이트(C#): 


=====
메모리 구조
코드 영역: 프로그램 상에서 실행할 소스코드가 저장되는 영역
>> CPU에서 해당 코드들을 가져가서 하나씩 처리
>> 프로그램이 실행되고나서부터 종료될 때까지 메모리에 계속 남아있음


데이터 영역: 전역변수와 정적(static)변수가 저장되는 영역
>> 전역 변수: 프로그램이 실행될 때 생성되어, 종료될 때까지 소멸되지 않는 변수
>> 정적 변수: 


힙 영역: 프로그래머가 직접 공간을 할당, 해제하는 메모리 공간
>> 동적 할당?
>> malloc() 또는 new 연산자를 통해 메모리를 할당하고 free또는 delete연산자를 통해 메모리를 해제
>> FIFO(먼저 들어간 놈이 먼저 나감)의 방식
	-> 메모리의 낮은 주소에서 높은 주소의 방향으로 할당되기 때문>>???
>>런타임 시기에 크기 결정



스택 영역: 프로그램이 자동으로 사용하는 (임시 메모리 영역?)
>>정적 할당?
>> 함수의 실행이 완료되면, 스택에 저장된 메모리가 소멸됨
>>
>>컴파일 시기에 크기 결정


정적할당: 컴파일 단계에서 필요한 메모리 공간을 할당하는 것
>> 스택에 저장된다
동적할당: 실행 단계에서 메모리 공간을 할당해주는 것
>>힙에 저장된다

정적 바인딩: 
동적 바인딩: 

정적 메모리: 
동적 메모리: 

할당: 무언가를 제공한다는 의미? >> ~(무엇)를 확보한다.

변수: 프로그램 코드 상에서 기능을 구현하기 전에 바탕이 될 재료
전역 변수: 함수 밖에서 선언한 변수. 프로그램 종료 전까지 잔재. 클래스 외부에서 선언
지역 변수: 함수 내에서 선언한 변수. 해당 함수 종료시 소멸
정적 변수: 
멤버 변수: 함수 밖에서 선언한 변수. 프로그램 종료 전까지 메모리에 잔재. 클래스 내부에서 선언
정적 멤버 변수: 

전역변수와 멤버변수는 같은 의미로 봐도 무방한가?
>>멤버 변수는 클래스 내에 함수 외적으로 선언한 변수?이고
>>전역 변수는 클래스 외부에서 선언한 변수이다?

C++에서 ::의 역할
>> 범위 지정 연산자

범위 지정 연산자: 같은 함수나 변수가 2개 이상 존재할 때 사용해야할 영역을 정하기 위한 연산자


주소 연산자 &: 변수의 메모리 주소값 반환

참조 연산자 *: 포인터의 이름이나 주소 앞에 사용하며
해당 주소를 참조하여 주소에 저장되어 있는 값을 반환
>> 실제 변수 값

포인터: 함수의 주소값

객체: 클래스 타입의 변수
=====

07/11 (목)

LinkedList.cpp #include <crtdbg.h> >> 메모리 누수 탐지 헤더

메모리누수
메모리누수 검사
객체 설계 시 내부에 외부에서 동적할당객체를 받는 것은 좋은 설계가 아님
호출 스택 
>> 함수가 호출된 순서
ㄴ 스택오버플로우

스마트포인터:
ㄴ 쉐어드포인터:
ㄴ 유니크포인터:
ㄴ 위크니스포인터:

가비지컬렉터:

클래스가 선언만 된 경우, 객체의 크기를 알 수 없기 때문에 참조자나 포인터로 선언한다.


7/12 (금)

포인터 참조자:
이중 포인터: 

행렬: 
ㄴ 이동행렬: 
ㄴ 회전행렬: 
ㄴ 부모행렬: 
ㄴ 자식행렬: 

오브젝트 풀링: 


7/15 (월)

그래픽API
ㄴOpenGL
ㄴㄴES
ㄴDirectX

batching: 

오픈소스: 소스코드를 누구나 볼 수 있고 사용할 수 있도록 제공하는 것
네이티브 프로그래밍: 자신의 플랫폼이 아닌 다른 플랫폼을 통해 
프로그래밍을 할 수 있는 도구
NDK: 네이티브 개발 도구
ㄴ안드로이드에서 C++ 프로그래밍을 연동할 때 사용하는 개발도구
JDK: 자바 개발도구
JNK: 
SDK: 
adb: 안드로이드 기기에 연결하여 커맨드라인을 기기에 전송해
조작할 수 있도록 돕는 콘솔프로그램
개발자 모드: 일반적인 사용자가 아닌 개발자가 개발을 하기 위하여 사용하는 모드
그래들 빌드: 안드로이드의 빌드 설정을 조정할 수 있는 스크립트.
AppData: 앱에서만 사용가능한 폴더, 앱에 필요한 파일을 쓰거나 읽는 것을 저장한다.
>>보안 상 문제가 발생할 수 있으므로 허용하지 않아야함.
타겟API:
.Net:
Mono:
IL2CPP:

파일: 텍스트, 바이너리 형식
ㄴ텍스트: 파일을 읽을 수 있는 글자로 저장하는 것(인코딩: UTF-8, ANSI)
ㄴ바이너리: 메모리를 그대로 저장하는 것

시리얼라이즈(직렬화): 객체를 버퍼화하여 저장한다.
버퍼: 어떤 데이터를 저장하기 위해 만들어진 데이터 배열 >> Unsigned Char buffer[255]
ㄴ변수에 데이터가 있다면? RAM
ㄴ파일로 데이터를 저장하면? ROM(HDD, SSD)

[네트워크]
포트포워딩: 
루프 백 주소: 자신의 기기에 서버로 연결

디스코드 -> 모바일 플랫폼 -> GameActivity, AndroidGame2D 다운로드

adb연결하는 방법
>>같은 와이파이 연결된 폰과 PC USB연결
>> adb connect ~~~

과제
C/C# 파일 저장하고 읽기(텍스트, 바이너리 형식)
C언어에서 시리얼라이즈 구현해보기

7/18 (목)

//Direct3D

셰이더: 
셰이딩: 

재질(Material): 
광원: 
벡터: 
평면: 
왼손 좌표계: 
랜더링 파이프라인:  
광선(Raycast): 
버텍스: 
정점: 
내적: 
외적: 
sqrt: 제곱근 계산(>> )
스칼라: 
